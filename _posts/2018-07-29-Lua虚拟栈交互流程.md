---
layout:     post
title:      Lua虚拟栈交互流程
subtitle:   分析Lua和C如何交互的
date:       2018-07-29
author:     Bob
header-img: img/post-bg-lua.jpg
catalog: true
tags:
    - Lua
---

>当C和Lua互相调用的时候，Lua虚拟栈严格的按照LIFO规则操作，只会改变虚拟栈顶部分。但通过Lua的API，可以查询虚拟栈上的任何元素，甚至是在任何一个位置插入和删除元素。

![image](/img/pos_5.png)

### C 调用 Lua



### Lua 调用 C


### C# 调用 C
在Unity中Mono 和 C 通讯使用 [P/Invoke](https://msdn.microsoft.com/zh-cn/library/aa686045.aspx),
P/Invoke又名平台调用，是.NET CLR提供的，为了使开发者从托管代码(如题主的C#)调用动态连接库中的非托管代码（通常是C）而提供的一种服务。类似的功能，JAVA中叫JNI，Python中叫Ctypes。而在这期间一个重要的工作就是marshall：让托管代码中的数据和原生代码中的数据可以相互访问。
因为不同语言，不同开发环境的数据类型、结构都是不同的，当你使用P/Invoke调用dll的时候，平台会自动给你加载这个dll，并且在托管代码和非托管代码的边界自动完成数据类型转换。
使用P/Invoke的话，一般分为3步：声明，调用，异常处理。

举例，在[xlua.dll](https://github.com/Tencent/xLua)里有一个如下签名的函数：
```c
     LUALIB_API lua_State *luaL_newstate (void) 
```
我们在C#中声明

```c#
DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)]
public static extern IntPtr luaL_newstate();
```

这样cs代码中的luaL_newstate函数最终都会调用到上面原生代码的luaL_newstate函数中。

在托管代码层面，所有的数据类型都被分为两类：blittable或者non-blittable。
**blittable类型**意味着在托管和原生代码中，内存的表现是一致的，没有区别（比如：byte，int，float）。
**Non-blittable类型**在两者中的内存表现就不一致。（比如：bool，string，array）。正因为这样，blittable类型数据能够直接传递给原生代码，但是non-blittable类型就需要做转换工作了。而这个转换工作很自然的就牵扯到新内存的分配。

正因为**marshall是一个很重量的工作**，所以考量一个Lua热更新框架是否优良的标准之一就是LuaL指令是否合理调用。

c#函数调用c函数走的是P/Invoke方式，明显的效率没法与c与lua的组合相比，而这种方式不好避免。云风团队用纯 C# 实现了一个 [Lua 5.2 虚拟机](https://github.com/xebecnan/UniLua)来避免这种marshall,但最终没有上线使用。而掌趣科技完全脱离Lua，使用内置的IL解译执行虚拟机来执行DLL中的代码，自行设计一套[IL托管栈](https://ourpalm.github.io/ILRuntime/public/v1/guide/principle.html)来做数据转换。。




