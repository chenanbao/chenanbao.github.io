---
layout:     post
title:      Lua热更新框架差异
subtitle:   方案选型考量方向
date:       2018-07-30
author:     Bob
header-img: img/post-bg-lua.jpg
catalog: true
tags:
    - Lua
---


### 闲谈国产游戏脚本渊源
端游时代一款[《天龙八部》](http://tl.changyou.com)就支撑了整个畅游公司。它引擎改造于orge+cegui。当c++代码工程随着项目业务日益庞大时，编译速度就实在很令人发狂。而C++对于开发人员要求还是蛮高的，驾驭不好给项目稳定性带来很大风险。再则为了更好分离引擎和业务逻辑，所以引入Lua做脚本语言作了部分业务逻辑开发。包括《魔兽世界》、《大话西游2》也引入Lua脚本。

早期页游大多基于Js+html+css开发,以Mop的[《猫游记》](http://www.pet.mop.com)最为代表,然而这种开发模式在浏览器兼容性和脚本执行效率、Dom效率等诸多问题上难以支撑重量产品。而后Flash As3发布,高效的脚本执行效率和统一的浏览器标准迎来页游黄金时代，mmorpg明星产品[《神仙道》](https://sxd.xd.com)，SNS游戏[《偷菜》](http://qqapp.qq.com/app/353.html)风靡大江南北。这二种页游开发模式都是基于web部署,就无需考虑引入其他脚本做热更模块。

移动浪潮迎来手游时代，对于iOS游戏而言，app store的审核周期漫长无比，再加上IOS不允许动态下发可执行代码（不支持JIT的硬件环境）。就必须引入脚本做bug修复和一些需要及时发布的业务模块。而Android应用发布平台混乱,本身设计机制上就可以相对自由的替换so、dex、dll达到热更目的。在游戏App领域Cocos引擎，引入js和lua热更方案。其他传统App热更就百花齐放，如被封杀闹得沸沸扬扬的[JsPatch](http://www.jspatch.com)。还有大量线上环境验证过的阿里[AndFix](https://github.com/alibaba/AndFix)和微信[Tinker](http://www.tinkerpatch.com)。

手游时代还有一个不能忽略的是Html5游戏，国外引擎有[Three.js](https://threejs.org/)、[Pixi.js](www.pixijs.com/)、[PlayCanvas](https://playcanvas.com/),这些国外引擎工具链不太完善，设计理念并不太符合做国产游戏开发模式。而国内做的比较完善的引擎有[Cocos2d-JS](http://www.cocos.com/docs/js/index.html)、[Egret](https://www.egret.com)、[Layabox](https://www.layabox.com)。这些主流的引擎还是运行在JavaScript上。渲染模式部分采用Canvas模式。也有采用webGL（JS版的OpenGL）这种性能更好的模式，而且浏览器对它支持也越来越普及。由于手机浏览器性能差异、接口缺陷、SDK接入、系统级调用等诸多问题。大多数H5游戏发布还是绑在特定的runtime上，如发布在微信小游戏平台(WebGL)、发布原生包。正因本质还是web机制，所以做热更还是很容易的。

最后说说[WebAssembly](https://webassembly.org)，它是一种二进制格式的类汇编代码，可以被浏览器加载和并进一步编译成可执行的机器码，从而在浏览器运行。它还可以作为高级语言的编译目标，理论上任何语言都可以编译为 WebAssembly。它接近 native code 比 JS 快这是显然的，作为浏览器四大巨头google、apple、firefox、microsoft合作共谋的产物，前途一片光明。目前支持的游戏引擎有
[Egret](https://www.egret.com)。而Unity在发布WebGl时也可以选择[Linker Target]((https://docs.unity3d.com/Manual/class-PlayerSettingsWebGL.html))为WebAssembly。

#### 常见的Lua for Unity3d框架
+ [SLua](https://github.com/pangweiwei/slua)
+ [Tolua](https://github.com/topameng/tolua)
+ [XLua](https://github.com/Tencent/xLua)

还有[ILRuntime](https://github.com/Ourpalm/ILRuntime)采用C#热更，以后单做分析。

#### 性能测评差异

这些Lua框架本质上都采用胶水代码调用Lua CAPI来实现C#、Lua、C交互,理论上没有性能差异，但网上性能测评都是体现出了不少差异。差异主要体现在下面二个方面：
 +  Lua 的 C API 的调用频次。
 +  C#、Lua、C、C++之间数据(值类型、引用类型)传递的实现方式和选择，以及数据交换产生的GC问题。

早期一些Lua框架桥接采用反射实现,会有性能损耗(几个框架测评相互嘲讽的点)，目前大多数框架都是采用Wrap方式生成胶水代码,因此这个性能差异基本抹平了。
 
大多测评用例是对Unity独有类型Vector2， Vector3，Vector4，Quaternion）使用、对象获取、函数调用、复杂类型传递等，下面分别讨论这些情况的实现方式。

##### Slua v1.6.0


##### Tolua v1.0.7.392
ToLua对于Lua CAPI调用优化点在于做了一定批处理。


##### Xlua v2.1.12

###### Unity独有类型使用

1.构造Vector3默认的映射方案是Vector3 -> userdata，userdata(size=12)比table(64位空table size ~= 80)更省内存，但操作字段比table性能稍低。
因经过了C#直接操作内存,所以性能略有损失。其他Unity类型Color、Quaternion等都是采用这种方案。

核心Lua CAPI调用过程如下：

```
lua_tonumber：lua虚拟栈3次出栈拿到xyz
xlua_pushstruct：构造userdata
xlua_pack_float3: 写入到数据到userdata

```

下列代码是完整调用过程:

```lua
--lua端
CS.UnityEngine.Vector3(1998, 2010, 1984)
```

```csharp
// UnityEngineVector3Wrap.cs Vector3构造函数
static int __CreateInstance(RealStatePtr L){
    ...
    float _x = (float)LuaAPI.lua_tonumber(L, 2);
    float _y = (float)LuaAPI.lua_tonumber(L, 3);
    float _z = (float)LuaAPI.lua_tonumber(L, 4);
                        
    UnityEngine.Vector3 gen_ret = new UnityEngine.Vector3(_x, _y, _z);
    translator.PushUnityEngineVector3(L, gen_ret);
    ...
}

//WrapPusher.cs  userdata
 void PushUnityEngineVector3(RealStatePtr L, UnityEngine.Vector3 val){
    IntPtr buff = LuaAPI.xlua_pushstruct(L, 12, UnityEngineVector3_TypeID);
    CopyByValue.Pack(buff, 0, val)
}

//PackUnPack.cs userdata
bool Pack(IntPtr buff, int offset, UnityEngine.Vector3 field){
    if(!LuaAPI.xlua_pack_float3(buff, offset, field.x, field.y, field.z)){
        return false;
    }     
    return true;
}
```

```c
/*xlua.c*/
typedef struct {
	int fake_id;
    unsigned int len;
	char data[1];
} CSharpStruct;

LUA_API void *xlua_pushstruct(lua_State *L, unsigned int size, int meta_ref) {
	CSharpStruct *css = (CSharpStruct *)lua_newuserdata(L, size + sizeof(int) + sizeof(unsigned int));
	css->fake_id = -1;
	css->len = size;
    lua_rawgeti(L, LUA_REGISTRYINDEX, meta_ref);
	lua_setmetatable(L, -2);
	return css;
}

LUALIB_API int xlua_pack_float3(void *p, int offset, float f1, float f2, float f3) {
	CSharpStruct *css = (CSharpStruct *)p;
	if (css->fake_id != -1 || css->len < offset + sizeof(float) * 3) {
		return 0;
	} else {
		float *pos = (float *)(&(css->data[0]) + offset);
		pos[0] = f1;
		pos[1] = f2;
		pos[2] = f3;
		return 1;
	}
}
```


2.lua里写入一个值到C# Vector3字段x，代码看出操作了userdata

核心Lua CAPI调用过程如下：

```
lua_tonumber：lua虚拟栈1次出栈拿到x值
Vector3.x = value:更新x值
lua_touserdata：取userdata
xlua_pack_float3: 更新到数据到userdata(实际xyz都写入了)

```

下列代码是完整调用过程：
```csharp
static int _s_set_x(RealStatePtr L){
    ...   
    UnityEngine.Vector3 gen_to_be_invoked;
    translator.Get(L, 1, out gen_to_be_invoked);
    gen_to_be_invoked.x = (float)LuaAPI.lua_tonumber(L, 2);      
    translator.UpdateUnityEngineVector3(L, 1, gen_to_be_invoked);
    ...  
}

//WrapPusher.cs  userdata
void UpdateUnityEngineVector3(RealStatePtr L, int index, UnityEngine.Vector3 val){
    IntPtr buff = LuaAPI.lua_touserdata(L, index);
    CopyByValue.Pack(buff, 0,  val);
}

//PackUnPack.cs  userdata
bool Pack(IntPtr buff, int offset, UnityEngine.Vector3 field){
    if(!LuaAPI.xlua_pack_float3(buff, offset, field.x, field.y, field.z)){
        return false;
    }     
    return true;
}
```

3.将Vector3写入transform到position有二种方式：传LUA_TUSERDATA或者LUA_TTABLE

核心Lua CAPI调用过程如下：
```
lua_type:判断类型

//type为userdata
lua_touserdata：取userdata
xlua_unpack_float3: 读userdata中xyz

//type为table
{
xlua_pushasciistring:入栈FieldName：x
lua_rawget:通过FieldName找table中x的值并入虚拟栈
lua_tonumber:出栈拿到x值
}*3次

```


下列代码是完整调用过程：

```lua
--lua端
transform.position = CS.UnityEngine.Vector3(1, 2, 3) --userdata
transform.position = {x = 2008, y = 8, z = 8}  --table
```

```csharp
// UnityEngineVector3Wrap.cs
static int _s_set_position(RealStatePtr L){
    UnityEngine.Transform gen_to_be_invoked = (UnityEngine.Transform)translator.FastGetCSObj(L, 1);
    UnityEngine.Vector3 gen_value;
    translator.Get(L, 2, out gen_value);
    gen_to_be_invoked.position = gen_value;
}

//WrapPusher.cs 判断是userdata还是table
public void Get(RealStatePtr L, int index, out UnityEngine.Vector3 val)
{
    LuaTypes type = LuaAPI.lua_type(L, index);
    if (type == LuaTypes.LUA_TUSERDATA )
    {
	    if (LuaAPI.xlua_gettypeid(L, index) != UnityEngineVector3_TypeID)
		{
		    throw new Exception("invalid userdata for UnityEngine.Vector3");
		}
		
        IntPtr buff = LuaAPI.lua_touserdata(L, index);
        if (!CopyByValue.UnPack(buff, 0, out val))
        {
            throw new Exception("unpack fail for UnityEngine.Vector3");
        }
    }
    else if (type ==LuaTypes.LUA_TTABLE)
    {
	    CopyByValue.UnPack(this, L, index, out val);
    }
    else
    {
        val = (UnityEngine.Vector3)objectCasters.GetCaster(typeof(UnityEngine.Vector3))(L, index, null);
    }
}

//userdata
 public static bool UnPack(IntPtr buff, int offset, out UnityEngine.Vector3 field)
 {
     field = default(UnityEngine.Vector3);
    
     float x = default(float);
     float y = default(float);
     float z = default(float);
    
     if(!LuaAPI.xlua_unpack_float3(buff, offset, out x, out y, out z))
     {
         return false;
     }
     field.x = x;
     field.y = y;
     field.z = z;
    
    
     return true;
 }

//table
public static void UnPack(ObjectTranslator translator, RealStatePtr L, int idx, out UnityEngine.Vector3 val){
    val = new UnityEngine.Vector3();
    int top = LuaAPI.lua_gettop(L);

    if (Utils.LoadField(L, idx, "x")){
        translator.Get(L, top + 1, out val.x);
    }
    LuaAPI.lua_pop(L, 1);

    if (Utils.LoadField(L, idx, "y")){
        translator.Get(L, top + 1, out val.y);
    }
    LuaAPI.lua_pop(L, 1);

    if (Utils.LoadField(L, idx, "z")){
        translator.Get(L, top + 1, out val.z);
    }
    LuaAPI.lua_pop(L, 1);	
}

//table
public static bool LoadField(RealStatePtr L, int idx, string field_name)
{
    idx = idx > 0 ? idx : LuaAPI.lua_gettop(L) + idx + 1;// abs of index
    LuaAPI.xlua_pushasciistring(L, field_name);
    LuaAPI.lua_rawget(L, idx);
    return !LuaAPI.lua_isnil(L, -1);
}

```

```c
/*userdata*/
LUALIB_API int xlua_unpack_float3(void *p, int offset, float *f1, float *f2, float *f3) {
	CSharpStruct *css = (CSharpStruct *)p;
	if (css->fake_id != -1 || css->len < offset + sizeof(float) * 3) {
		return 0;
	} else {
		float *pos = (float *)(&(css->data[0]) + offset);
		*f1 = pos[0];
		*f2 = pos[1];
		*f3 = pos[2];
		return 1;
	}
}

```


4.也可以将自定义的C# struct映射到lua table或者userdata 。

自定义struct规则：
a.含无参构造函数 
b.只包含值类型
c.可以嵌套其它只包含值类型的struct

```csharp
//ReImplementInLua.cs--table
[GCOptimize(OptimizeFlag.PackAsTable)]
public struct PushAsTableStruct
{
    public int x;
    public int y;
}

//NoGc.cs -- userdata
[GCOptimize]
[LuaCallCSharp]
 public struct MyStruct
{
    public MyStruct(int p1, int p2)
    {
        a = p1;
        b = p2;
        c = p2;
        e.c = (byte)p1;
    }
    public int a;
    public int b;
    public decimal c;
    public Pedding e;
}

```
5.xlua.genaccessor支持lua使用C#类型直接在lua侧完成，而且省掉了wrap代码以达成省text段的效果。
**xlua.genaccessor不经过C#直接操作内存,效率应该是最高的。**

```lua
--具体事例参见ReImplementInLua.cs
local get_x, set_x = xlua.genaccessor(0, 8)
```

```c
/*xlua.c*/

static const luaL_Reg xlualib[] = {
	{"sethook", profiler_set_hook},
	{"genaccessor", gen_css_access},
	{"structclone", css_clone},
	{NULL, NULL}
};

LUA_API int gen_css_access(lua_State *L) {
	int offset = xlua_tointeger(L, 1);
	int type = xlua_tointeger(L, 2);
	if (offset < 0) {
		return luaL_error(L, "offset must larger than 0");
	}
	if (type < T_INT8 || type > T_DOUBLE) {
		return luaL_error(L, "unknow tag[%d]", type);
	}
	lua_pushvalue(L, 1);
	lua_pushcclosure(L, direct_getters[type], 1);
	lua_pushvalue(L, 1);
	lua_pushcclosure(L, direct_setters[type], 1);
	lua_pushcclosure(L, nop, 0);
	return 3;
}
```

###### 对象获取

C#侧ObjectPool(数组)保存的是id<->c# object映射，
Lua侧用userdata建立和C#关系,GC过程都是基于这个模型构建。

```lua
--lua
local gobject = CS.UnityEngine.GameObject.Find('helloworld')
gobject.transform
```

```csharp
//UnityEngineGameObjectWrap.cs
 static int _g_get_transform(RealStatePtr L){
    try {
        ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);
        //通过id(udata)在ObjectTranslator.objects(对象池Array)取c#对象，有boxing（装箱）行为
        UnityEngine.GameObject gen_to_be_invoked = (UnityEngine.GameObject)translator.FastGetCSObj(L, 1);
        //Push做了二步工作：
        //1.把transform push到objects中
        //2.transform对象id通过xlua_pushcsobj push到userdata
        translator.Push(L, gen_to_be_invoked.transform);
    } catch(System.Exception gen_e) {
        return LuaAPI.luaL_error(L, "c# exception:" + gen_e);
    }
    return 1;
}
//ObjectTranslator.cs
internal object FastGetCSObj(RealStatePtr L,int index){
    return getCsObj(L, index, LuaAPI.xlua_tocsobj_fast(L,index));
}

/*xlua.c*/
/*通过userdata拿id*/
LUA_API int xlua_tocsobj_fast (lua_State *L,int index) {
	int *udata = (int *)lua_touserdata (L,index);

	if(udata!=NULL) 
		return *udata;
	return -1;
}

LUA_API void xlua_pushcsobj(lua_State *L, int key, int meta_ref, int need_cache, int cache_ref) {
	int* pointer = (int*)lua_newuserdata(L, sizeof(int));
	*pointer = key;
	
	if (need_cache) cacheud(L, key, cache_ref);

    lua_rawgeti(L, LUA_REGISTRYINDEX, meta_ref);

	lua_setmetatable(L, -2);
}

```

###### Lua调用CSharp函数

先包装一个LuaCSFunction函数,再通过Utils.RegisterFunc来注册C#函数，
包装函数必须打[MonoPInvokeCallbackAttribute]标签，为什么打标签参见[Unity文档](https://docs.unity3d.com/Manual/TroubleShootingIPhone.html)和[Mono文档](https://developer.xamarin.com/api/type/MonoMac.MonoPInvokeCallbackAttribute/)。

因为注册函数只需要消耗一次，**其性能瓶颈主要就在c#函数的参数出栈(xlua_toXXX)和返回值的入栈(xlua_pushXXX)上**。

```csharp

--lua
xxx:TestFunc(2008)

//c#函数
public void TestFunc(int i)
{
}

//按规则包装一个函数给C 
[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate int lua_CSFunction(IntPtr L);
[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
static int _m_TestFunc(RealStatePtr L)
 {
    ....
    //函数参数：出栈取值   
    int _i = LuaAPI.xlua_tointeger(L, 2);
    //c#函数调用
    gen_to_be_invoked.TestFunc( _i );
    //返回值处理
    ...
    //返回值个数
    return 0;
    ....
 }

//注册函数,这样非托管代码就可以反向调用托管代码了
LuaAPI.xlua_pushasciistring(L, name);
IntPtr fn = Marshal.GetFunctionPointerForDelegate(function);
/*lua_pushcfunction*/
xlua_push_csharp_function(L, fn, n);
LuaAPI.lua_rawset(L, idx);

```

###### CSharp调用Lua
1.读G表数据
```lua
--lua
money = 99999
```

```csharp
//c#
luaenv.Global.Get<int>("money")
```

在LuaTable.Get主要做了如下LuaCAPI工作：
```csharp
lua_pushstring(L,"money")
lua_gettable(L,-2)
xlua_tointeger(L,-1);
```

2.C#调Lua函数是把Lua函数映射到delegate的模式然后调用
这种模式因为函数参数和返回值类型双方都明确，从而避免了Boxing。

```csharp

--lua
function f(a, b)
    print('a', a, 'b', b)
    return 1, {f1 = 1024}
end

//用例CSCallLua.cs
[CSharpCallLua]
public delegate int FDelegate(int a, string b, out DClass c);

//在DelegatesGensBridge.cs里生成映射参数关系,调用大致做下面三个步骤
public int __Gen_Delegate_Imp13(int p0, string p1, out CSCallLua.DClass p2)
{
....
LuaAPI.xlua_pushXXX //参数处理
LuaAPI.lua_pcall //lua函数执行
LuaAPI.xlua_toXXX //返回值处理
....
}

```


#### 工程质量
 
最后讨论一下三个框架实现耦合度、可扩展性和集成C++库便利性。

#### 优化


#### Xlua的GC处理



