---
layout:     post
title:      Lua热更新框架差异
subtitle:   方案选型考量方向
date:       2018-07-30
author:     Bob
header-img: img/post-bg-lua.jpg
catalog: true
tags:
    - Lua
---


### 闲谈国产游戏脚本渊源
端游时代一款[《天龙八部》](http://tl.changyou.com)就支撑了整个畅游公司。它引擎改造于orge+cegui。当c++代码工程随着项目业务日益庞大时，编译速度就实在很令人发狂。而C++对于开发人员要求还是蛮高的，驾驭不好给项目稳定性带来很大风险。再则为了更好分离引擎和业务逻辑，所以引入Lua做脚本语言作了部分业务逻辑开发。包括《魔兽世界》、《大话西游2》也引入Lua脚本。

早期页游大多基于Js+html+css开发,以Mop的[《猫游记》](http://www.pet.mop.com)最为代表,然而这种开发模式在浏览器兼容性和脚本执行效率、Dom效率等诸多问题上难以支撑重量产品。而后Flash As3发布,高效的脚本执行效率和统一的浏览器标准迎来页游黄金时代，mmorpg明星产品[《神仙道》](https://sxd.xd.com)，SNS游戏[《偷菜》](http://qqapp.qq.com/app/353.html)风靡大江南北。这二种页游开发模式都是基于web部署,就无需考虑引入其他脚本做热更模块。

移动浪潮迎来手游时代，对于iOS游戏而言，app store的审核周期漫长无比，再加上IOS不允许动态下发可执行代码（不支持JIT的硬件环境）。就必须引入脚本做bug修复和一些需要及时发布的业务模块。而Android应用发布平台混乱,本身设计机制上就可以相对自由的替换so、dex、dll达到热更目的。在游戏App领域Cocos引擎，引入js和lua热更方案。其他传统App热更就百花齐放，如被封杀闹得沸沸扬扬的[JsPatch](http://www.jspatch.com)。还有大量线上环境验证过的阿里[AndFix](https://github.com/alibaba/AndFix)和微信[Tinker](http://www.tinkerpatch.com)。

手游时代还有一个不能忽略的是Html5游戏，国外引擎有[Three.js](https://threejs.org/)、[Pixi.js](www.pixijs.com/)、[PlayCanvas](https://playcanvas.com/),这些国外引擎工具链不太完善，设计理念并不太符合做国产游戏开发模式。而国内做的比较完善的引擎有[Cocos2d-JS](http://www.cocos.com/docs/js/index.html)、[Egret](https://www.egret.com)、[Layabox](https://www.layabox.com)。这些主流的引擎还是运行在JavaScript上。渲染模式部分采用Canvas模式。也有采用webGL（JS版的OpenGL）这种性能更好的模式，而且浏览器对它支持也越来越普及。由于手机浏览器性能差异、接口缺陷、SDK接入、系统级调用等诸多问题。大多数H5游戏发布还是绑在特定的runtime上，如发布在微信小游戏平台(WebGL)、发布原生包。正因本质还是web机制，所以做热更还是很容易的。

最后说说[WebAssembly](https://webassembly.org)，它是一种二进制格式的类汇编代码，可以被浏览器加载和并进一步编译成可执行的机器码，从而在浏览器运行。它还可以作为高级语言的编译目标，理论上任何语言都可以编译为 WebAssembly。它接近 native code 比 JS 快这是显然的，作为浏览器四大巨头google、apple、firefox、microsoft合作共谋的产物，前途一片光明。目前支持的游戏引擎有
[Egret](https://www.egret.com)。而Unity在发布WebGl时也可以选择[Linker Target]((https://docs.unity3d.com/Manual/class-PlayerSettingsWebGL.html))为WebAssembly。

#### 常见的Lua for Unity3d框架
+ [SLua](https://github.com/pangweiwei/slua)
+ [Tolua](https://github.com/topameng/tolua)
+ [XLua](https://github.com/Tencent/xLua)

还有[ILRuntime](https://github.com/Ourpalm/ILRuntime)采用C#热更，以后单做分析。

#### 性能测评差异

这样Lua框架本质上都采用胶水代码调用Lua CAPI来实现C#、Lua、C交互,理论上没有性能差异，但网上测评都是体现出了不少差异。这些差异主要体现在二个方面：
 +  Lua 的 C API 的调用频次。
 +  C#、Lua、C、C++之间数据(值类型、引用类型)传递的实现方式和选择，以及数据产生的GC问题

早期一些Lua框架桥接采用反射实现,会有性能损耗(几个框架测评相互嘲讽的点)，目前大多数框架都是采用Wrap方式生成胶水代码,因此这个性能差异基本抹平了。
 
大多测评用例是对Unity独有类型Vector2， Vector3，Vector4，Quaternion）使用、对象获取、函数调用、复杂类型传递等，下面分别讨论这些情况的实现方式。

###### Slua v1.6.0


###### Tolua v1.0.7.392
ToLua对于Lua CAPI调用优化点在于做了一定批处理。


###### Xlua v2.1.12
1.在Xlua中Vector3默认的映射方案是Vector3 -> userdata，userdata(size=12)比table更省内存，但操作字段比table性能稍低。
因经过了C#直接操作内存,所以性能略有损失。其他Unity类型Color、Quaternion等都是采用这种方案。

```lua
--lua端
CS.UnityEngine.Vector3(1, 2, 3)
```

```csharp
// UnityEngineVector3Wrap.cs
static int __CreateInstance(RealStatePtr L){
    ...
    float _x = (float)LuaAPI.lua_tonumber(L, 2);
    float _y = (float)LuaAPI.lua_tonumber(L, 3);
    float _z = (float)LuaAPI.lua_tonumber(L, 4);
                        
    UnityEngine.Vector3 gen_ret = new UnityEngine.Vector3(_x, _y, _z);
    translator.PushUnityEngineVector3(L, gen_ret);
    ...
}

//WrapPusher.cs
 void PushUnityEngineVector3(RealStatePtr L, UnityEngine.Vector3 val){
    IntPtr buff = LuaAPI.xlua_pushstruct(L, 12, UnityEngineVector3_TypeID);
    CopyByValue.Pack(buff, 0, val)
}

```

```c
/*xlua.c*/
typedef struct {
	int fake_id;
    unsigned int len;
	char data[1];
} CSharpStruct;

LUA_API void *xlua_pushstruct(lua_State *L, unsigned int size, int meta_ref) {
	CSharpStruct *css = (CSharpStruct *)lua_newuserdata(L, size + sizeof(int) + sizeof(unsigned int));
	css->fake_id = -1;
	css->len = size;
    lua_rawgeti(L, LUA_REGISTRYINDEX, meta_ref);
	lua_setmetatable(L, -2);
	return css;
}
```

2.操作一个Vector3字段，代码看出实际就是操作userdata

```csharp
static int _s_set_x(RealStatePtr L){
    ...   
    UnityEngine.Vector3 gen_to_be_invoked;translator.Get(L, 1, out gen_to_be_invoked);
    gen_to_be_invoked.x = (float)LuaAPI.lua_tonumber(L, 2);      
    translator.UpdateUnityEngineVector3(L, 1, gen_to_be_invoked);
    ...  
}

//WrapPusher.cs
void UpdateUnityEngineVector3(RealStatePtr L, int index, UnityEngine.Vector3 val){
    IntPtr buff = LuaAPI.lua_touserdata(L, index);
    CopyByValue.Pack(buff, 0,  val);
}
```

3.xlua.genaccessor支持lua使用C#类型直接在lua侧完成，而且省掉了wrap代码以达成省text段的效果。

```lua
--具体事例参见ReImplementInLua.cs
local get_x, set_x = xlua.genaccessor(0, 8)
```

```c
/*xlua.c*/

static const luaL_Reg xlualib[] = {
	{"sethook", profiler_set_hook},
	{"genaccessor", gen_css_access},
	{"structclone", css_clone},
	{NULL, NULL}
};

LUA_API int gen_css_access(lua_State *L) {
	int offset = xlua_tointeger(L, 1);
	int type = xlua_tointeger(L, 2);
	if (offset < 0) {
		return luaL_error(L, "offset must larger than 0");
	}
	if (type < T_INT8 || type > T_DOUBLE) {
		return luaL_error(L, "unknow tag[%d]", type);
	}
	lua_pushvalue(L, 1);
	lua_pushcclosure(L, direct_getters[type], 1);
	lua_pushvalue(L, 1);
	lua_pushcclosure(L, direct_setters[type], 1);
	lua_pushcclosure(L, nop, 0);
	return 3;
}
```

4.考虑操作userdata性能损失,可以将C# struct映射到lua table

```csharp
//具体事例参见ReImplementInLua.cs和NoGc.cs
[GCOptimize(OptimizeFlag.PackAsTable)]
public struct PushAsTableStruct
{
    public int x;
    public int y;
}
```



#### 工程质量
 
最后讨论一下三个框架实现耦合度、可扩展性和集成C++库便利性。



#### Xlua的GC处理



