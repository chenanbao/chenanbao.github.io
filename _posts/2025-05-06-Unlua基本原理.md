---
 layout:     post
 title:      Unlua基本原理
 subtitle:   源码阅读
 date:       2025-05-06
 author:     Bob
 header-img: img/post-bg-rwd.jpg
 catalog: true
 tags:
     - Unreal
---

##### 动态绑定

UE可以使用AddUObjectCreateListener侦听创建UObject

```c++

//UObjectBase.cpp
void UObjectBase::AddObject(FName InName, EInternalObjectFlags InSetInternalFlags, int32 InInternalIndex, int32 InSerialNumber)
{
	NamePrivate = InName;
	EInternalObjectFlags InternalFlagsToSet = InSetInternalFlags;
	if (!IsInGameThread())
	{
		InternalFlagsToSet |= EInternalObjectFlags::Async;
	}
	if (ObjectFlags & RF_MarkAsRootSet)
	{		
		InternalFlagsToSet |= EInternalObjectFlags::RootSet;
		ObjectFlags &= ~RF_MarkAsRootSet;
	}
	if (ObjectFlags & RF_MarkAsNative)
	{
		InternalFlagsToSet |= EInternalObjectFlags::Native;
		ObjectFlags &= ~RF_MarkAsNative;
	}
	GUObjectArray.AllocateUObjectIndex(this, InternalFlagsToSet, InInternalIndex, InSerialNumber);
	check(InName != NAME_None && InternalIndex >= 0);
	HashObject(this);
	check(IsValidLowLevel());
}

//UObjectArray.cpp
void FUObjectArray::AllocateUObjectIndex(UObjectBase* Object, EInternalObjectFlags InitialFlags, int32 AlreadyAllocatedIndex, int32 SerialNumber)
{
    ...
    for (int32 ListenerIndex = 0; ListenerIndex < UObjectCreateListeners.Num(); ListenerIndex++)
	{
		UObjectCreateListeners[ListenerIndex]->NotifyUObjectCreated(Object,Index);
	}
}

void FUObjectArray::AddUObjectCreateListener(FUObjectCreateListener* Listener)
{
	check(!UObjectCreateListeners.Contains(Listener));
	UObjectCreateListeners.Add(Listener);
}

```

UnLuaModule.cpp里注册了UObject的创建，还替换了UObject的Input绑定函数

```c++

        virtual void SetActive(const bool bActive) override
        {
            if (bIsActive == bActive)
                return;

            if (bActive)
            {
                OnHandleSystemErrorHandle = FCoreDelegates::OnHandleSystemError.AddRaw(this, &FUnLuaModule::OnSystemError);
                OnHandleSystemEnsureHandle = FCoreDelegates::OnHandleSystemEnsure.AddRaw(this, &FUnLuaModule::OnSystemError);
                GUObjectArray.AddUObjectCreateListener(this);
                GUObjectArray.AddUObjectDeleteListener(this);
                ....
            }
        }

        virtual void NotifyUObjectCreated(const UObjectBase* ObjectBase, int32 Index) override
        {
            // UE_LOG(LogTemp, Log, TEXT("NotifyUObjectCreated : %p"), ObjectBase);
            if (!bIsActive)
                return;

            UObject* Object = (UObject*)ObjectBase;

            const auto Env = EnvLocator->Locate(Object);
            // UE_LOG(LogTemp, Log, TEXT("Locate %s for %s"), *Env->GetName(), *ObjectBase->GetFName().ToString());
            Env->TryBind(Object);
            Env->TryReplaceInputs(Object);
        }

```

经过一系列检查后，最终通过Bind来动态绑定

```c++

UnLua::FLuaEnv* ULuaEnvLocator::Locate(const UObject* Object)
{
    if (!Env)
    {
        Env = MakeShared<UnLua::FLuaEnv, ESPMode::ThreadSafe>();
        Env->Start();
    }
    return Env.Get();
}

FString ULuaModuleLocator::Locate(const UObject* Object)
{
    const UObject* CDO;
    if (Object->HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject))
    {
        CDO = Object;
    }
    else
    {
        const auto Class = Cast<UClass>(Object);
        CDO = Class ? Class->GetDefaultObject() : Object->GetClass()->GetDefaultObject();
    }

    if (CDO->HasAnyFlags(RF_NeedInitialization))
    {
        // CDO还没有初始化完成
        return "";
    }

    if (!CDO->GetClass()->ImplementsInterface(UUnLuaInterface::StaticClass()))
    {
        return "";
    }

    return IUnLuaInterface::Execute_GetModuleName(CDO);
}

/**
 * Bind a Lua module for a UObject
 */
bool UUnLuaManager::Bind(UObject *Object, const TCHAR *InModuleName, int32 InitializerTableRef)
{
    check(Object);

    const auto Class = Object->IsA<UClass>() ? static_cast<UClass*>(Object) : Object->GetClass();
    lua_State *L = Env->GetMainState();

    if (!Env->GetClassRegistry()->Register(Class))
        return false;

    // try bind lua if not bind or use a copyed table
    UnLua::FLuaRetValues RetValues = UnLua::Call(L, "require", TCHAR_TO_UTF8(InModuleName));
    FString Error;
    if (!RetValues.IsValid() || RetValues.Num() == 0)
    {
        Error = "invalid return value of require()";
    }
    else if (RetValues[0].GetType() != LUA_TTABLE)
    {
        Error = FString("table needed but got ");
        if(RetValues[0].GetType() == LUA_TSTRING)
            Error += UTF8_TO_TCHAR(RetValues[0].Value<const char*>());
        else
            Error += UTF8_TO_TCHAR(lua_typename(L, RetValues[0].GetType()));
    }
    else
    {
        BindClass(Class, InModuleName, Error);
    }

    if (!Error.IsEmpty())
    {
        UE_LOG(LogUnLua, Warning, TEXT("Failed to attach %s module for object %s,%p!\n%s"), InModuleName, *Object->GetName(), Object, *Error);
        return false;
    }

    // create a Lua instance for this UObject
    Env->GetObjectRegistry()->Bind(Class);
    Env->GetObjectRegistry()->Bind(Object);

    // try call user first user function handler
    int32 FunctionRef = PushFunction(L, Object, "Initialize");                  // push hard coded Lua function 'Initialize'
    if (FunctionRef != LUA_NOREF)
    {
        if (InitializerTableRef != LUA_NOREF)
        {
            lua_rawgeti(L, LUA_REGISTRYINDEX, InitializerTableRef);             // push a initializer table if necessary
        }
        else
        {
            lua_pushnil(L);
        }
        bool bResult = ::CallFunction(L, 2, 0);                                 // call 'Initialize'
        if (!bResult)
        {
            UE_LOG(LogUnLua, Warning, TEXT("Failed to call 'Initialize' function!"));
        }
        luaL_unref(L, LUA_REGISTRYINDEX, FunctionRef);
    }

    return true;
}

```

这三个是预先bind的UBlueprintFunctionLibrary / UAnimNotifyState / UAnimNotify

##### 静态绑定

1.对实现UUnLuaInterface的对象处理
2.通过BEGIN_EXPORT_CLASS等宏标记

[官方静态导出说明](https://github.com/Tencent/UnLua/blob/master/Docs/CN/StaticExportBinding.md)

##### GC

当lua侧UObject为LUA_NOREF，将其设置为0xDEAD

```c++

  const static UObject* ReleasedPtr = (UObject*)0xDEAD;

  FORCEINLINE bool IsReleasedPtr(const void* Ptr) { return Ptr == ReleasedPtr; }


    bool IsUObjectValid(UObjectBase* ObjPtr)
    {
        if (!ObjPtr || ObjPtr == LowLevel::ReleasedPtr)
            return false;
        return (ObjPtr->GetFlags() & (RF_BeginDestroyed | RF_FinishDestroyed)) == 0 && ObjPtr->IsValidLowLevelFast();
    }


            check(lua_isuserdata(L, -1));
            bool bTwoLvlPtr;
            void* Userdata = GetUserdataFast(L, -1, &bTwoLvlPtr);
            check(bTwoLvlPtr)
            *((void**)Userdata) = (void*)LowLevel::ReleasedPtr;
            lua_settop(L, Top);

```

##### UE5.5编译

先自己尝试修改了一波，后来发现这个分支https://github.com/Lanaoti/Tencent-UnLua/commit/06a8caa0a84cce26bcea7a8877b8e132e1dd23c7#diff-a30b19f23c39f0bd3b99f75d26bc3b8fc3b4612fd79d021991061114d85fc8c6

启动编译错误修改如下
+ TPSProject.Target.cs和TPSProjectEditor.Target.cs中DefaultBuildSettings = BuildSettingsVersion.V2修改为DefaultBuildSettings = BuildSettingsVersion.V5;
+ 所有.Build.cs中的bEnableUndefinedIdentifierWarnings = false; 修改为UndefinedIdentifierWarningLevel = WarningLevel.Off;
+ UnLuaDefaultParamCollectorUbtPlugin.ubtplugin.csproj中<TargetFramework>net6.0</TargetFramework>改为<TargetFramework>net8.0</TargetFramework>
+ UnLuaDefaultParamCollectorUbtPlugin.cs修改Generate函数
```csharp
        //UnLuaDefaultParamCollectorUbtPlugin.cs
        private void Generate()
        {
            /*
            foreach (UhtPackage package in Session.Packages)
            {
                var moduleType = package.Module.ModuleType;
                ParseModule(package.Module.Name, moduleType, package.Module.OutputDirectory);
                if (moduleType != UHTModuleType.EngineRuntime && moduleType != UHTModuleType.GameRuntime)
                {
                    continue;
                }
                QueueClassExports(package, package);
            }
            
            // Wait for all the classes to export
            Finish();
            */
            
            foreach (UhtModule module in Session.Modules)
            {
                foreach (UhtPackage package in module.Packages)
                {
                    var moduleType = package.Module.Module.ModuleType;
                    ParseModule(package.Module.Module.Name, moduleType, package.Module.Module.OutputDirectory);
                    if (moduleType != UHTModuleType.EngineRuntime && moduleType != UHTModuleType.GameRuntime)
                    {
                        continue;
                    }
                    QueueClassExports(package, package);
                }
            }
            // Wait for all the classes to export
            Finish();
        }

```
+ TChooseClass改为std::conditional
+ EAutomationTestFlags::ApplicationContextMask改为EAutomationTestFlags_ApplicationContextMask

