---
 layout:     post
 title:      水
 subtitle:   水的几种制作方式
 date:       2019-04-03
 author:     Bob
 header-img: img/post-bg-unity.jpg
 catalog: true
 tags:
     - Unity
---


#### ShaderGraph制作水

水效果：
![image](/img/water1.gif)

属性：
![image](/img/water1.jpg)


节点图如下：
![image](/img/water1.png)

节点函数用途：

```c
    // Shared Graph Node Functions
 
    void Unity_FresnelEffect_float(float3 Normal, float3 ViewDir, float Power, out float Out)
    {
        Out = pow((1.0 - saturate(dot(normalize(Normal), normalize(ViewDir)))), Power);
    }
 
    void Unity_Power_float(float A, float B, out float Out)
    {
        Out = pow(A, B);
    }
 
    void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
    {
        Out = lerp(A, B, T);
    }
 
    void Unity_Multiply_float (float A, float B, out float Out)
    {
        Out = A * B;
    }
 
    void Unity_Multiply_float (float2 A, float2 B, out float2 Out)
    {
        Out = A * B;
    }
 
    void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
    {
        Out = UV * Tiling + Offset;
    }
 
    void Unity_NormalBlend_float(float3 A, float3 B, out float3 Out)
    {
        Out = normalize(float3(A.rg + B.rg, A.b * B.b));
    }

```

#### 基于海岸深度水

水效果：
![image](/img/water2.gif)

属性：
![image](/img/water2.jpg)

```c

Shader "Map/Sea" {
	Properties {
		//水
		_WaterAlphaTex ("WaterAlphaTex", 2D) = "black" {} 
		_WaterNormalTex ("WaterNormalTex", 2D) = "bump" {} 
		_WaterGradient ("WaterGradient", 2D) = "white" {} 
		_WaterNosieTex ("WaterNoise", 2D) = "white" {} 
		_WaterSpeed ("WaterSpeed", float) = 0.74 
		_Refract("Refract", float) = 0.07
		_Specular("Specular", float) = 1.86
		_Gloss("Gloss", float) = 0.71
		_SpecColor("SpecColor", color) = (1, 1, 1, 1)
		_CoastRange("CoastRange", vector) = (0.13, 1.53, 0.37, 0.78)
		//浪花
		_FoamTex("FoamTex", 2D) = "black" {}
		_FoamSpeed ("FoamSpeed", float) = -12.64 
		_FoamRange ("FoamRange", float) = 0.3 
		_FoamDelta("FoamDelta", float) = 2.43
		_FoamNoiseRange ("FoamNoiseRange", float) = 6.43
		
	}
	CGINCLUDE 
	fixed4 LightingSeaLight(SurfaceOutput s, fixed3 lightDir, half3 viewDir, fixed atten) {
		half3 halfVector = normalize(lightDir + viewDir);
		float diffFactor = max(0, dot(lightDir, s.Normal)) * 0.8 + 0.2;
		float nh = max(0, dot(halfVector, s.Normal));
		float spec = pow(nh, s.Specular * 128.0) * s.Gloss;
		fixed4 c;
		c.rgb = (s.Albedo * _LightColor0.rgb * diffFactor + _SpecColor.rgb * spec * _LightColor0.rgb) * (atten);
		c.a = s.Alpha + spec * _SpecColor.a;
		return c;
	}
	ENDCG
	SubShader {
		Tags { "RenderType"="Transparent" "Queue"="Transparent"}
		LOD 200

		GrabPass{}
		zwrite off
		
		CGPROGRAM
		#pragma surface surf SeaLight vertex:vert alpha noshadow
		#pragma target 3.0

		sampler2D _WaterAlphaTex;
		float4 _WaterAlphaTex_TexelSize;

		sampler2D _WaterGradient;
		sampler2D _WaterNormalTex;
		sampler2D _WaterNosieTex;
		sampler2D _FoamTex;

		sampler2D _CameraDepthTexture;
		sampler2D _GrabTexture;
		half4 _GrabTexture_TexelSize;
		
		float4 _CoastRange;
		half _WaterSpeed;
		fixed _Refract;
		half _Specular;
		fixed _Gloss;

		half _FoamNoiseRange;
		half _FoamSpeed;
		fixed _FoamDelta;
		half _FoamRange;
		

		struct Input {
			float2 uv_WaterAlphaTex;
			float2 uv_WaterNosieTex;
			float4 proj;
			float3 viewDir;
		};

		void vert (inout appdata_full v, out Input i) {
			UNITY_INITIALIZE_OUTPUT(Input, i);
			i.proj = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
			COMPUTE_EYEDEPTH(i.proj.z);
		}

		fixed4 uvMove(sampler2D tex,float2 uv,float offset){
			fixed4 colorX = tex2D(tex, uv + offset + float2(_WaterSpeed*_Time.x,0));
			fixed4 colorXY = tex2D(tex, float2(1-uv.y,uv.x)  + offset + float2(_WaterSpeed*_Time.x,0));
			fixed4 color = (colorX+colorXY)/2;
			return color;
		}

		float coastDepth(float rang,float depth){
			return min(rang, depth)/rang;
		}

		fixed4 coastWaveColor(fixed delta,half deltaDepth,float offset,fixed4 noiseColor){
			fixed4 waveColor = tex2D(_FoamTex, float2(1-coastDepth(_CoastRange.z, deltaDepth)+_FoamRange*sin(_Time.x*_FoamSpeed+delta+noiseColor.r*_FoamNoiseRange),1)+offset);
			waveColor.rgb *= (1-(sin(_Time.x*_FoamSpeed+delta+noiseColor.r*_FoamNoiseRange)+1)/2)*noiseColor.r;
			return waveColor;
		}

		void surf (Input IN, inout SurfaceOutput o) {
			float2 uv = IN.proj.xy/IN.proj.w;
			#if UNITY_UV_STARTS_AT_TOP
			if(_WaterAlphaTex_TexelSize.y<0)
			uv.y = 1 - uv.y;
			#endif

			fixed4 waterAlpha = uvMove(_WaterAlphaTex,IN.uv_WaterAlphaTex,half2(0,0));

			float4 offsetColor = uvMove(_WaterNormalTex,IN.uv_WaterAlphaTex,half2(0,0));
			
			half2 offset = UnpackNormal(offsetColor).xy * _Refract;
			half deltaDepth = LinearEyeDepth(tex2Dproj (_CameraDepthTexture, IN.proj).r) - IN.proj.z;

			fixed4 wateNoiseColor = tex2D(_WaterNosieTex, IN.uv_WaterNosieTex);

			half4 seafloor = tex2D(_GrabTexture, uv+offset);
			fixed4 waterColor = tex2D(_WaterGradient, float2(coastDepth(_CoastRange.y, deltaDepth),1));
			
			fixed4 waveColorA = coastWaveColor(0,deltaDepth,offset,wateNoiseColor);
			fixed4 waveColorB = coastWaveColor(_FoamDelta,deltaDepth,offset,wateNoiseColor);
			
			half water_A = 1-coastDepth(_CoastRange.z, deltaDepth);
			half water_B = coastDepth(_CoastRange.w, deltaDepth);

			float4 normalColor = uvMove(_WaterNormalTex,IN.uv_WaterAlphaTex,offset);

			o.Normal = UnpackNormal(normalColor).xyz;
			
			o.Specular = _Specular;
			o.Gloss = _Gloss;
			o.Albedo = seafloor.rgb * (1 - water_B) + waterColor.rgb * water_B;
			o.Albedo = o.Albedo * (1 - waterAlpha.a*water_A) + waterAlpha.rgb * waterAlpha.a*water_A;
			o.Albedo += (waveColorA.rgb+waveColorB.rgb) * water_A; 

			//o.Albedo = water;
			
			o.Alpha = coastDepth(_CoastRange.x, deltaDepth);
		}
		ENDCG
	} 
	//FallBack "Diffuse"
}


```


