---
 layout:     post
 title:      数据结构与算法
 subtitle:   哈希表、字符串
 date:       2019-09-15
 author:     Bob
 header-img: img/post-bg-unity.jpg
 catalog: true
 tags:
     - C++
---

以下题目均来自leetcode、poj

##### [最长回文串](https://leetcode.com/problems/longest-palindrome) 

给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。

注意:
假设字符串的长度不会超过 1010。

示例 1:

输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。



```c

class Solution {
public:
    int longestPalindrome(string s) {
        int charMap[128] = 0;
        int maxLength = 0;
        int flag = 0;
        for (int i = 0; i < s.length(); i++) {
            charMap[s[i]]++;
        }
        for (int i = 0; i < 128; i++) {
            if(charMap[i] %2 ==  0){
                //字符为偶数全部可用

                max_length += charMap[i];
            }else{
                //为奇数 拿一个出来，最后当中心点

                max_length += charMap[i] - 1;
                flag = 1;
            }
        }
        reutrn max_length + flag;
    }
};

```

##### [单词规律](https://leetcode.com/problems/word-pattern) 


给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。

这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。

示例1:

输入: pattern = "abba", str = "dog cat cat dog"
输出: true
示例 2:

输入:pattern = "abba", str = "dog cat cat fish"
输出: false
示例 3:

输入: pattern = "aaaa", str = "dog cat cat dog"
输出: false
示例 4:

输入: pattern = "abba", str = "dog dog dog dog"
输出: false
说明:
你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 




```c

class Solution {
public:
    bool wordPattern(string pattern, string str) {
        std::vector<std::string,char> word_map;
        char used[128] = {0};
        std::string word;
        int pos = 0;
        str.push_back(' ');
        for (i = 0; i < str.length();i++){
            if(str[i] == ' '){
                //找到最后都找不到
                
                if(pos == pattern.length()){
                    reutrn false;
                }
                if(word_map.find(word) == word_map.end()){
                    if(used[pattern[pos]]){
                        return false;
                    }
                    word_map[word] = pattern[pos];
                    used[pattern[pos]] = 1;
                }else{
                    if(word_map[word] != pattern[pos]){
                        return false;
                    }
                }
                word = "";
                pos++;
            }else{
                word += str[i];
            }
        }
        if(pos != pattern.length()){
            return false;
        }
        return true;
    }
};


```

##### []() 

```c


```

##### []() 

```c


```


##### []() 

```c


```


##### []() 

```c


```