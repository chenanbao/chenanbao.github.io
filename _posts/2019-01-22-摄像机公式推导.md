---
 layout:     post
 title:      摄像机公式推导
 subtitle:   Perspective&Ortho
 date:       2019-1-21
 author:     Bob
 header-img: img/post-bg-unity.jpg
 catalog: true
 tags:
     - Unity
---


#### 正交投影

![image](/img/d_10.png)

观察坐标为右手坐标系，NDC使用左手坐标系。定义屏幕左右边界为left和right 屏幕上下边界为top和bottom，近的裁剪面距离为n，远的裁剪面距离为f。

观察空间的x_eye、y_eye与z_eye分量都线性映射到NDC。我们只需将长方体缩放为正方体，然后移动它到原点。让我们使用线性关系推导所有元素。

![image](/img/d_13.png)

投影矩阵:一个缩放和平移矩阵结合。

![image](/img/d_12.png)


Unity源码实现
```c++

m_ProjectionMatrix.SetOrtho( -m_OrthographicSize * m_Aspect, m_OrthographicSize * m_Aspect, -m_OrthographicSize, m_OrthographicSize, m_NearClip, m_FarClip );

Matrix4x4f& Matrix4x4f::SetOrtho (
	float left,
	float right,
	float bottom,
	float top,
	float zNear,
	float zFar )
{
	SetIdentity ();

	float deltax = right - left;
	float deltay = top - bottom;
	float deltaz = zFar - zNear;

	Get(0,0) = 2.0F / deltax;
	Get(0,3) = -(right + left) / deltax;
	Get(1,1) = 2.0F / deltay;
	Get(1,3) = -(top + bottom) / deltay;
	Get(2,2) = -2.0F / deltaz;
	Get(2,3) = -(zFar + zNear) / deltaz;
	return *this;
}
```

#### 透视投影

![image](/img/d_11.png)

在透视投影中，观察坐标中的3D点会被映射到立方体（NDC:Normalized Device Coordinates ）中。x坐标的范围从[l,f]到[-1,1]，y坐标的范围从[b,t]到[-1,1]，z坐标的范围从[n,f]到[-1,1]。


下图显示了观察坐标中的点（x_eye，y_eye，z_eye）如何投影到近平面上的（x_p，y_p，z_p），其通过使用相似三角形的比率来计算。

![image](/img/d_16.png)

注意，x_p和y_p都取决于z_eye ; 它们与-z_eye成反比。换句话说，它们都被-z_eye除以。

\begin{bmatrix}
x_{clip}\\ 
y_{clip}\\ 
z_{clip}\\
w_{clip}
\end{bmatrix} = M_{projection}\begin{bmatrix}
x_{eye}\\ 
y_{eye}\\ 
z_{eye}\\
w_{eye}
\end{bmatrix}  \\

\begin{bmatrix}
x_{ndc}\\ 
y_{ndc}\\ 
z_{ndc}
\end{bmatrix} = \begin{bmatrix}
x_{clip}/w_{clip}\\ 
y_{clip}/w_{clip}\\ 
z_{clip}/w_{clip}
\end{bmatrix} 

如上正交投影推导一样x_p和y_p映射到具有线性关系的NDC的x_ndc和y_ndc有如下二式。

![image](/img/d_17.png)

推出下列矩阵：

![image](/img/d_18.png)

再推导z_ndc:

![image](/img/d_19.png)

最后得出透视投影矩阵，它是通用的，左右两边不对称。投影点不在屏幕中心点。

![image](/img/d_20.png)

Unity中源码实现为：

```c++
Matrix4x4f& Matrix4x4f::SetFrustum (
	float left,
	float right,
	float bottom,
	float top,
	float nearval,
	float farval )
{
	float x, y, a, b, c, d, e;
	    
	x =  (2.0F * nearval) 		/ (right - left);
	y =  (2.0F * nearval) 		/ (top - bottom);
	a =  (right + left)			/ (right - left);
	b =  (top + bottom)			/ (top - bottom);
	c = -(farval + nearval)		   / (farval - nearval);
	d = -(2.0f * farval * nearval) / (farval - nearval);
	e = -1.0f;

	Get (0,0) = x;    Get (0,1) = 0.0;  Get (0,2) = a;   Get (0,3) = 0.0;
	Get (1,0) = 0.0;  Get (1,1) = y;    Get (1,2) = b;   Get (1,3) = 0.0;
	Get (2,0) = 0.0;  Get (2,1) = 0.0;  Get (2,2) = c;   Get (2,3) = d;
	Get (3,0) = 0.0;  Get (3,1) = 0.0;  Get (3,2) = e;	Get (3,3) = 0.0;
	return *this;
}

```

而unity editor中使用的fov和aspect来处理相机。

![image](/img/d_15.png)

+ fov是视景体竖直方向上的张角，如侧视图所示。

+ aspect等于width / height，是照相机水平方向和竖直方向长度的比值。

+ near和far分别是照相机到视景体最近、最远的距离，均为正值，且far应大于near。

当上图椎体对称时，其 right left 大小相同 一正一负，投影点正好在屏幕中心点


![image](/img/d_21.png)

投影矩阵简化为：

![image](/img/d_22.png)

再带入二个fov和aspect系数:

![image](/img/d_23.png)

得出Unity使用的透视投影矩阵,


![image](/img/d_24.png)


Unity中源码实现为：
```c++

m_ProjectionMatrix.SetPerspective( m_FieldOfView, m_Aspect, m_NearClip, m_FarClip );

Matrix4x4f& Matrix4x4f::SetPerspective(
	float fovy,
	float aspect,
	float zNear,
	float zFar )
{
	float cotangent, deltaZ;
	float radians = Deg2Rad (fovy / 2.0f);
	cotangent = cos (radians) / sin (radians);
	deltaZ = zNear - zFar;
	
	Get (0,0) = cotangent / aspect;	Get (0,1) = 0.0F;      Get (0,2) = 0.0F;                    Get (0,3) = 0.0F;
	Get (1,0) = 0.0F;               Get (1,1) = cotangent; Get (1,2) = 0.0F;                    Get (1,3) = 0.0F;
	Get (2,0) = 0.0F;               Get (2,1) = 0.0F;      Get (2,2) = (zFar + zNear) / deltaZ; Get (2,3) = 2.0F * zNear * zFar / deltaZ;
	Get (3,0) = 0.0F;               Get (3,1) = 0.0F;      Get (3,2) = -1.0F;                   Get (3,3) = 0.0F;

	return *this;
}
```

参考资料：

[gl_projectionmatrix](http://www.songho.ca/opengl/gl_projectionmatrix.html)