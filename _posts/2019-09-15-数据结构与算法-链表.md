---
 layout:     post
 title:      数据结构与算法
 subtitle:   链表
 date:       2019-09-15
 author:     Bob
 header-img: img/post-bg-unity.jpg
 catalog: true
 tags:
     - C++
---

##### [翻转链表](https://leetcode.com/problems/reverse-linked-list/)

反转一个单链表。

示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL


```c

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;//节点值

 *     ListNode *next;//下一个节点

 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = NULL;
        ListNode* curr = head;
        ListNode* next = NULL;
        
        while (curr) {
            next = curr->next;//备份当前节点的下一个节点

            curr->next = prev;//更新当前节点

            prev = curr;//当前节点保留为下一个节点的前节点

            curr = next;//当前节点移动到下一个节点

        }
        
        return prev;
    }
};

void test206(){
    ListNode a;
    a.value  = 10;
    
    ListNode b;
    b.value  = 20;
    
    ListNode c;
    c.value  = 30;
    
    ListNode d;
    d.value  = 40;
    
    ListNode e;
    e.value  = 50;
    
    a.next = &b;
    b.next = &c;
    c.next = &d;
    d.next = &e;
    e.next = NULL;
    
    Solution206 s;
    ListNode* result = s.reverseList(&a);
    
    ListNode *head = result;
    while(head){
        cout << head->value << endl;
        head = head->next;
    }
}


```

##### [翻转链表](https://leetcode.com/problems/reverse-linked-list-ii/)

反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:

输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL

```c
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        int change_len = n - m + 1;//反转的个数

        ListNode* pre_head = NULL;

        ListNode* result = head;

        while(head && --m){ //找到反转的开始位置

            pre_head = head;//反转区间第一个节点的前节点

            head = head->next;
        }

        
        ListNode *reverse_tail = head;//反转后的尾节点

        ListNode *new_head = NULL;
        
        while(head && change_len){//开始反转

            ListNode* next = head->next;

            head->next = new_head;

            new_head = head;

            head = next;

            change_len--;

        }
        
        //反转后的尾节点的下一个节点 为剩余节点的头结点

        reverse_tail->next = head;
       
        if(pre_head){ //不是从第一个节点开始反转

          pre_head->next = new_head;
        }else{
          result = new_head;//new_head为反转后的头

        }
        return result;
    }
};
```