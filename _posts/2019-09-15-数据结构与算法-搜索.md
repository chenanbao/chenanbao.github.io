---
 layout:     post
 title:      数据结构与算法
 subtitle:   搜索
 date:       2019-09-15
 author:     Bob
 header-img: img/post-bg-unity.jpg
 catalog: true
 tags:
     - C++
---

以下题目均来自leetcode、poj

##### [岛屿数量](https://leetcode.com/problems/number-of-islands) 

给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。

示例 1:

输入:
11110
11010
11000
00000

输出: 1
示例 2:

输入:
11000
11000
00100
00011

输出: 3

```c

class Solution {
private:
   void DFS(std::vector<std::vector<int>> &mark,
   std::vector<std::vector<char>> &grid,int x,int y){
       static const int dx[] = {-1,1,0,0};
       static const int dy[] = {0,0,-1,1};
       mark[x][y] = 1;
       for(int i = 0;i < 4;i++){
           int newx = x+dx[i];
           int newy = y+dx[j];
           if(newx < 0 || newx > mark.size() || 
            newy < 0 || newy > mark[newx].size() || 
            ){
                continue;
            }
            if(mark[newx][newy] == 0 && grid[newx][newy] == '1'){
                DFS(mark,grind,newx,newy);
            }
       }
   }

   void BFS(std::vector<std::vector<int>> &mark,
   std::vector<std::vector<char>> &grid,int x,int y){
       static const int dx[] = {-1,1,0,0};
       static const int dy[] = {0,0,-1,1};
       mark[x][y] = 1;
       std::queue<std::pair<int,int>> q;
       q.push(std::make_pair(x,y));
       while(!q.empty()){
           x = q.front().first;
           y = q.front().second;
           q.pop();
           for(int i = 0;i < 4;i++){
            int newx = x+dx[i];
            int newy = y+dx[j];
            if(newx < 0 || newx > mark.size() || 
            newy < 0 || newy > mark[newx].size() || 
            ){
                continue;
            }
            if(mark[newx][newy] == 0 && grid[newx][newy] == '1'){
                q.push(std::make_pair(newx,newy));
                mark[newx][newy] = 1;
            }
           }
       }
   }
public:
    int numIslands(vector<vector<char>>& grid) {
        int islandNum = 0;
        std::vector<std::vector<int>> mark;
        for(int i = 0;i < grid.size();i++){
            mark.push_back(std::vector<int>());
            for(int j = 0;j < grid[i].size();j++){
                mark[i].push_back(0);
            }
        }
        for(int i = 0;i < grid.size();i++){
            mark.push_back(std::vector<int>());
            for(int j = 0;j < grid[i].size();j++){
                if(grid[i][j] == '1' && mark[i][j] == 0){
                    DFS(mark,grid,i,j);
                    islandNum++;
                }
            }
        }
        return islandNum;
    }
};


```

##### [单词接龙](https://leetcode.com/problems/word-ladder) 

给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：

每次转换只能改变一个字母。
转换过程中的中间单词必须是字典中的单词。
说明:

如果不存在这样的转换序列，返回 0。
所有单词具有相同的长度。
所有单词只由小写字母组成。
字典中不存在重复的单词。
你可以假设 beginWord 和 endWord 是非空的，且二者不相同。
示例 1:

输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出: 5

解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。
示例 2:

输入:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

输出: 0

解释: endWord "cog" 不在字典中，所以无法进行转换。



```c

class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        
    }
};


```

##### []() 

```c


```

##### []() 

```c


```

##### []() 

```c


```