---
 layout:     post
 title:      渲染管线
 subtitle:   Per-Sample Processing
 date:       2019-1-19
 author:     Bob
 header-img: img/post-bg-unity.jpg
 catalog: true
 tags:
     - Unity
---

#### 渲染管线

![image](/img/pip.001.jpg)

#### Scissor Test


#### Alpha Test
在使用fragment程序时[ShaderLab Alpha Test](https://docs.unity3d.com/Manual/SL-AlphaTest.html)命令无效，用[cg clip](https://developer.download.nvidia.cn/cg/clip.html)函数来处理。

![image](/img/u_127.png)

```c
Shader "Unlit/Clip"
{
	Properties
	{
		_MainTex ("Texture", 2D) = "white" {}
		_CutOff("CutOff",Range(0,1)) = 0.5
	}
	SubShader
	{
		Tags { "RenderType"="Opaque" }
		LOD 100

		Pass
		{
			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag

			#include "UnityCG.cginc"

			struct appdata
			{
				float4 vertex : POSITION;
				float2 uv : TEXCOORD0;
			};

			struct v2f
			{
				float2 uv : TEXCOORD0;

				float4 vertex : SV_POSITION;
			};

			sampler2D _MainTex;
			float4 _MainTex_ST;
			
			v2f vert (appdata v)
			{
				v2f o;
				o.vertex = UnityObjectToClipPos(v.vertex);
				o.uv = TRANSFORM_TEX(v.uv, _MainTex);
				return o;
			}
			
			float _CutOff;

			fixed4 frag (v2f i) : SV_Target
			{
				fixed4 col = tex2D(_MainTex, i.uv);
				clip(col.a-_CutOff);
				return col;
			}
			ENDCG
		}
	}
}


```

#### Stencil Test

[Stencil Test](https://docs.unity3d.com/Manual/SL-Stencil.html)语法如下:

```c
stencil{

    Ref referenceValue 
	
    ReadMask  readMask 
	
    WriteMask writeMask 

    Comp comparisonFunction 
	
    Pass stencilOperation 
	
    Fail stencilOperation 
	
    ZFail stencilOperation 
}
```

判断依据：

```c

if（referenceValue&readMask comparisonFunction stencilBufferValue&readMask）

通过像素

else

抛弃像素

```

+ ReferenceValue:该值用来比较（当 Comp 设置为非always）并／或 用来写入到buffer（如果任何Pass，Fail，ZFail被设置来代替他）。为 0–255 整数.

+ ReadMask:从字面意思的理解就是读遮罩，readMask将和referenceValue以及stencilBufferValue进行按位与（&）操作，readMask取值范围也是0-255的整数，默认值为255，二进制位11111111，即读取的时候不对referenceValue和stencilBufferValue产生效果，读取的还是原始值。

+ WriteMask:一个8 bit的mask，值为0-255的整数，当写入buffer时使用。注意，和其他写掩码一样，它指定的模版缓冲（stencil buffer）会被写操作影响。（例如：WriteMask 0 意味着没有bit会受影响，而不是0值会被写入）。 默认值为: 255.
	
+ comparisonFunction:该函数用来比较reference值和当前buffer中的内容。默认为: always.

| 取值 | 含义 | 
| ------ | ------ | 
| Greater|相当于“>”操作，即仅当左边>右边，模板测试通过，渲染像素|	
| GEqual|相当于“>=”操作，即仅当左边>=右边，模板测试通过，渲染像素|	
| Less	|相当于“<”操作，即仅当左边<右边，模板测试通过，渲染像素|	
| LEqual|相当于“<=”操作，即仅当左边<=右边，模板测试通过，渲染像素|	
| Equal	|相当于“=”操作，即仅当左边=右边，模板测试通过，渲染像素|	
| NotEqual|相当于“!=”操作，即仅当左边!=右边，模板测试通过，渲染像素|	
| Always|不管公式两边为何值，模板测试总是通过，渲染像素|	
| Never|不敢公式两边为何值，模板测试总是失败 ，像素被抛弃|	

+ stencilOperation:
    1、pass表示要做什么，当buffer内容通过了测试（以及深度测试）。 默认: keep.

    2、fail表示要做什么，当buffer的内容没有通过测试。 默认: keep.
    
    3、zfail做什么当buffer内容通过了stencil测试，但是没通过深度测试。 默认: keep.

| 取值 | 含义 | 
| ------ | ------ | 
| Keep| 保留当前缓冲中的内容，即stencilBufferValue不变。| 
| Zero| 将0写入缓冲，即stencilBufferValue值变为0。| 
| Replace| 将参考值写入缓冲，即将referenceValue赋值给stencilBufferValue。| 
| IncrSat| stencilBufferValue加1，如果stencilBufferValue超过255了，那么保留为255，即不大于255。| 
| DecrSat| stencilBufferValue减1，如果stencilBufferValue超过为0，那么保留为0，即不小于0。| 
| Invert| 将当前模板缓冲值（stencilBufferValue）按位取反| 
| IncrWrap| 当前缓冲的值加1，如果缓冲值超过255了，那么变成0，（然后继续自增。| 
| DecrWrap| 当前缓冲的值减1，如果缓冲值已经为0，那么变成255，（然后继续自减。| 




#### Depth Test


#### Alpah Blend


参考资料:

[Per-Sample_Processing](https://www.khronos.org/opengl/wiki/Per-Sample_Processing)

[Per-Fragment_Operations](https://en.wikibooks.org/wiki/GLSL_Programming/Per-Fragment_Operations)

[Cg 3.1 Toolkit Documentation](https://developer.download.nvidia.cn/cg/index.html)